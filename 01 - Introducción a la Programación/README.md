![HenryLogo](https://henry-11ty-resources.s3.sa-east-1.amazonaws.com/Assets/logo-henry-white-lg.png)

# Primeros Pasos

#### Preparando tu compu

<div class="iframeContainer">
  <iframe src="https://player.vimeo.com/video/638636752" title="Instructivo de Primeros Pasos" allow="autoplay; fullscreen"></iframe>
</div>

> **Importante**: Github cambi√≥ el m√©todo de autenticaci√≥n, ahora es por PAT (Personal Access Token), para crearlo pueden seguir este [link](https://docs.github.com/es/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token). Pueden elegir expiration infinita para hacerlo una s√≥la vez.

## C√≥mo usar SLACK

<div class="iframeContainer">
  <iframe src="https://player.vimeo.com/video/548902078" title="C√≥mo usar SLACK" allow="autoplay; fullscreen; picture-in-picture"></iframe>
</div>

> Gracias [Nico Constantin (FT#12)](https://github.com/NicoConstantin) por el video y la explicaci√≥n!

## Editores de Texto

Para poder escribir c√≥digo que pueda ser interpretado por un lenguaje de programaci√≥n, necesitamos utilizar un editor de texto.

Hay varios, puedes probarlos y optar por el que te sientas m√°s a gusto.

A continuaci√≥n veremos una lista de los m√°s populares:

### Sublime Text

![Sublime Text](/_src/assets/00-PrimerosPasos/sublimeText_screen.png)

Es un editor de texto liviano, que cuenta con una serie de plugins para adaptarlo a las necesidades de cada desarrollador.

Es multiplataforma, por lo que se puede instalar tanto en Windows, como Linux y OS X.

Para instalarlo, realizaremos los siguientes pasos:

#### En Windows o en OS X

1. Nos dirigimos a la p√°gina oficial de [Sublime Text](https://www.sublimetext.com).

2. Al ingresar, detectar√° autom√°ticamente el sistema operativo que tenemos, y nos sugerir√° descargar el instalador apropiado.

3. Presionamos el bot√≥n **_Download_**.

4. Elegimos la opci√≥n adecuada seg√∫n nuestro sistema operativo e iniciamos la descarga.

![Sublime Text Download](/_src/assets/00-PrimerosPasos/sublimeText_download.png)

5. Finalizada la descarga, ejecutamos el instalador, seleccionamos las opciones **_siguiente, siguiente, etc_**, hasta completar el proceso.

#### En Linux, en la distribuci√≥n Ubuntu y derivados

1. Nos dirigimos al sitio oficial de Sublime Text. Aqu√≠ encontrar√°s las instrucciones para instalarlo:

[Descargar Sublime Text para Linux](https://www.sublimetext.com/docs/3/linux_repositories.html)

2. En la terminal, ejecutamos el siguiente comando, para instalar la clave GPG:

```shell
wget -q0 - https://download.sublimetext.com/sublimehq-pub.gpg | sudo apt-key add -
```

3. Para asegurarnos de que `apt` est√© configurado para trabajar con or√≠genes https, ejecutamos:

```shell
sudo apt-get install apt-transport-https
```

4. Luego para agregar el repositorio estable, ejecutamos:

```shell
echo "deb https://download.sublimetext.com/ apt/stable/" | sudo tee /etc/apt/sources.list.d/sublime-text.list
```

5. Finalmente, procedemos a instalar el programa:

```shell
sudo apt-get install sublime-text
```

Ahora, si en el **Men√∫ de inicio** buscamos **Sublime text**, veremos la siguiente imagen:

![Sublime Text Linux](/_src/assets/00-PrimerosPasos/sublimeText_linux.png)

### Atom

![Atom Site](/_src/assets/00-PrimerosPasos/atom_site.png)

Es un editor de c√≥digo abierto, disponible tanto para Windows, como Linux y para OS X.

Tiene integrada una consola de Git y Github, para llevar un control de versiones de tus proyectos.
Para comenzar el proceso de instalaci√≥n, realizamos los siguientes pasos:

En Windows, Linux o en OS X, nos dirigimos al sitio oficial, mediante el siguiente enlace:

<https://atom.io/>

Al ingresar, el navegador detecta autom√°ticamente el instalador que necesitamos bajar, seg√∫n nuestro sistema operativo.

All√≠, presionamos el bot√≥n Download para almacenarlo en nuestra computadora.

#### En Windows

Una vez finalizada la descarga, hacemos doble click en el instalador y esperamos a que finalice el proceso de instalaci√≥n.

#### En Ubuntu y derivados

Descomprimimos el instalador, hacemos doble click, y nos dirigimos a: `/usr/bin/atom`

Al hacer doble click, se abrir√° el editor.

### Visual Studio Code

![VSC Console](/_src/assets/00-PrimerosPasos/vsc_console.png)

Es un editor desarrollado por Microsoft.

Tiene integrado el control de versiones mediante Git y Github para tener un seguimiento de tus proyectos. Brinda una cantidad de extensiones que facilitan el trabajo de un desarrollador.

Para descargarlo, nos dirigimos al sitio oficial, en la secci√≥n Dowload y descargamos el instalador seg√∫n nuestro Sistema Operativo:

<https://code.visualstudio.com/download>

![VSC Download](/_src/assets/00-PrimerosPasos/vsc_download.png)

Una vez finalizada la descarga, procedemos a ejecutar el instalador.

## Git

### ¬øQu√© es Git?

Git es un sistema de control de versiones, distribuido y open source. Un control de versiones es un sistema que registra los cambios realizados en un archivo o conjunto de archivos a lo largo del tiempo, de modo que puedas recuperar versiones espec√≠ficas m√°s adelante.

### Instalaci√≥n

#### Para Mac y Linux

Ver estos enlaces:

<https://git-scm.com/book/es/v2/Inicio---Sobre-el-Control-de-Versiones-Instalaci%C3%B3n-de-Git>

<https://www.youtube.com/watch?v=PSULlxUk744>

<https://www.youtube.com/watch?v=oV0spTF71AI>

#### Para Windows

Ingreso a <https://git-scm.com> y descargo la √∫tlima versi√≥n.

![installGit](/_src/assets/00-PrimerosPasos/instalar_window.png)

Una vez descargado, se abre el archivo .exe y van a visualizar la siguiente ventana

![installGit](/_src/assets/00-PrimerosPasos/1.png)

Clickeamos ‚ÄúNext‚Äù hasta que llegamos a esta parte:

![installGit](/_src/assets/00-PrimerosPasos/2.png)

En este momento de la instalaci√≥n si quieres puedes elegir el editor de texto que van a usar. (Importante, t√©nganlo instalado antes de instalar Git)

Seguimos clickeando ‚ÄúNext‚Äù y luego ‚ÄúInstall‚Äù

![installGit](/_src/assets/00-PrimerosPasos/3.png)

Por √∫ltimo, finalizar! Si seleccionan la opci√≥n "Launch Git Bash", una vez que finalizan la instalaci√≥n se va a abrir la consola

![installGit](/_src/assets/00-PrimerosPasos/4.png)

Otra forma de abrir la consola es haciendo click derecho sobre el escritorio y elegir la opci√≥n "Git Bash Here"

![installGit](/_src/assets/00-PrimerosPasos/consola.png)

Una vez instalado Git van a poder visualizar la consola: ingresamos el comando `git --version` para chequear que est√° instalado. Si ven la consola as√≠, ya est√°n listos para comenzar a trabajar!

![installGit](/_src/assets/00-PrimerosPasos/5.png)

## GitHub

### ¬øQu√© es GitHub?

Es una red para almacenar tus repositorios, ser√≠a un repositorio de repositorios. Es uno de los tantos disponibles en internet, y el m√°s popular. GitHub **NO** es lo mismo que Git, aunque funcionen muy bien juntos. Github es un lugar donde pod√©s compartir tu c√≥digo o encontrar otros proyectos. Tambi√©n act√∫a como portfolio para cualquier c√≥digo en el que hayas trabajado.

### Comenzando

1. Para comenzar nos creamos una cuenta --- > <https://github.com> üöÄ

![GitHub-Register](/_src/assets/00-PrimerosPasos/github_register.png)

2. Una vez registrados, ingresamos con usuario y contrase√±a:

![GitHub-Login](/_src/assets/00-PrimerosPasos/github_login.png)

3. Listo! Ahora vemos una p√°gina de inicio como la siguiente:

![GitHub-Home](/_src/assets/00-PrimerosPasos/github_home.png)

A la izquierda tenemos un acceso r√°pido a **mis repositorios**.

En el centro vemos la actividad de los usuarios a quienes seguimos.

En la parte superior derecha, vemos nuestra imagen de perfil. Desde ah√≠ podemos desplegar opciones para gestionar nuestro perfil, repositorios y configuraci√≥n. Si accedemos a nuestro perfil encontramos algo parecido a esto:

![GitHub-profile](/_src/assets/00-PrimerosPasos/github_profile.png)

Podemos poner una foto de perfil, editar el nombre, agregar la ubicaci√≥n, link y organizaciones a las que pertenecemos. En el centro podemos fijar los repositorios que queremos mostrar para que est√©n visibles en nuestro perfil.

M√°s abajo se muestra un diagrama de todas las contribuciones que vamos haciendo a los repositorios.

Si accedemos a la pesta√±a de arriba que dice `repositorios` veremos una lista de todos ellos. Cuando elegimos un repositorio para ver, nos lleva a una p√°gina como esta:

![GitHub-repo](/_src/assets/00-PrimerosPasos/github_repo.png)

As√≠ se ve un repositorio. Arriba a la izquierda tenemos el `nombre de usuario/nombre del repo`.

En el centro podemos ver todos los archivos que tiene dentro el repo. El bot√≥n verde que dice `Code` es importante, si clickeamos ah√≠ vamos a poder obtener la url del repo, para as√≠ poder **_clonarlo_** (esto lo veremos m√°s adelante).

Arriba a la derecha encontramos tres botones. `Watch` nos permite seguir un repositorio, mientras que con `Star` podemos marcar como favorito un repo que nos guste. Por √∫ltimo tenemos `Fork`, este es **muy** importante, lo vamos a necesitar cuando hagamos el **_Challenge!_**

Ya tenemos todo para empezar... √âxitos!!! üçÄ

## Instalaci√≥n de Python si est√°s usando Windows:

Python 3.7 (o superior
1. Para obtener el instalador dir√≠gete a [https://www.python.org/downloads/](https://www.python.org/downloads/)
2. Descarga el instalador y ejec√∫talo en tu computadora.
3. Habilita la casilla de verificaci√≥n en Install launcher for all users y Add Python 3.8 to PATH. A continuaci√≥n presiona en Install Now. Windows te solicitar√° permisos para instalar Python en tu computadora.
4. Al finalizar la instalaci√≥n se abrir√° una ventana, en ella deber√°s presionar en la opci√≥n Disable path length limit. Windows te solicitar√° permisos para realizar este cambio.

Visual Studio Code

Visual Studio Code es un editor de textos que tiene integradas varias herramientas que te ayudar√°n a desarrollar tus ejercicios con facilidad. Para obtenerlo en tu computadora, dir√≠gete a: [https://code.visualstudio.com/](https://code.visualstudio.com/)

1. Realiza una instalaci√≥n normal de Visual Studio code.
2. En Visual Studio Code dir√≠gete al panel de Extensiones, se encuentra en el panel lateral izquierdo. Ah√≠ deber√°s buscar la extensi√≥n llamada Python.
3. Selecciona la extensi√≥n creada por Microsoft. Una vez seleccionada, inst√°lala.
4. Una vez instalada, reinicia Visual Studio Code.

Listo con esto podr√°s correr los programas que escribas en python en la terminal de Visual Studio Code.

## Instalaci√≥n de Python si est√°s usando Mac:

Dir√≠gete a: [https://es.wikibooks.org/wiki/Python/Instalaci%C3%B3n_de_Python/Python_en_Mac_OS_X](https://es.wikibooks.org/wiki/Python/Instalaci%C3%B3n_de_Python/Python_en_Mac_OS_X)

## Instalaci√≥n de Python si est√°s usando Linux:

En una distribuci√≥n est√°ndar Linux dispone por defecto el interprete Python instalado, para comprobar la correcta instalaci√≥n solamente deber√≠a ejecutar el comando en la consola:

```bash
python
Python 2.7.13 (default, Sep 26 2018, 18:42:22)
[GCC 6.3.0 20170516] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>>
```

Si le muestra los mensajes anteriores esta correctamente instalado el interprete Python en su Linux.

Si al ejecutar el comando anterior muestra el mensaje:

```bash
python
bash: python: no se encontr√≥ la orden
```

Esto es debido a que no tiene instalado el interprete, as√≠ que debe ejecutar el siguiente comando:
```bash
sudo apt-get install -y python-dev
```

De nuevo vuelva a ejecutar en su consola de comando el comando python.

# Introducci√≥n a la Programaci√≥n

## ¬øQu√© es la Programaci√≥n?

En la imagen, se representa un peque√±o robot abeja en una esquina del cuadril√°tero, y en la otra una flor. El objetivo del robot abeja es llegar hasta la flor, esquivando los arbustos que hay de por medio. Para esto, hay que decirle c√≥mo se debe mover, pero puede saltar de a un casillero por vez y la forma en que se le puede "decir" es a travez de instrucciones. Esas instrucciones son "arriba", "abajo", "izquierda" y "derecha". Y por supuesto, teniendo en cuenta que debe moverse dentro del cuadril√°tero.

Ahora bien, surgen algunas preguntas:

* ¬øCu√°ntas instrucciones son necesarias?

* Al ser m√°s de una instrucci√≥n ¬øEs importante el orden en que se ejecutan?

* ¬øHay m√°s de una forma, en que el robot abeja pueda llegar a la flor?

* ¬øHay un camino √≥ptimo?

* ¬øC√≥mo puedo medir si un camino es el √≥ptimo con respecto a otros caminos?

![unaImagenConBoxShadow](../_src/assets/01_imagen01.jpg)

Cualquiera de las siguiente, podr√≠an ser una soluci√≥n:
* Derecha, Derecha, Arriba, Arriba, Derecha, Derecha, Arriba, Arriba, Arriba, Derecha, Derecha, Arriba
* Derecha, Derecha, Derecha, Derecha, Derecha, Derecha, Arriba, Arriba, Arriba, Izquierda, Izquierda, Arriba, Arriba, Derecha, Arriba, Derecha
* Arriba, Derecha, Derecha, Arriba, Arriba, Arriba, Arriba, Arriba, Derecha, Derecha, Derecha, Derecha, Arriba

Lo importante, en principio, es que notemos que al resolver el problema planteado, lo que estamos haciendo, utilizando un pensamiento l√≥gico, es precisamente, **programaci√≥n**

Entonces, **programar, es armar una secuencia l√≥gica de pasos a seguir, en pos de cumplir un objetivo.** En el ejemplo visto, tuvimos un contexto que nos marcaba las posibilidades y restricciones del problema, por ejemplo moverse dentro del cuadril√°tero √≥ no chocar con los arbustos. Y tambi√©n un conjunto de instrucciones disponibles, que definian el lenguaje que ten√≠amos que usar, para que el robot comprenda las instrucciones. Lo que usamos fue un lenguaje formal, muy b√°sico y que fue suficiente para resolver el problema. √âstos lenguajes, se denominan lenguajes de programaci√≥n, nos permiten plasmar esas instrucciones necesarias para darle una soluci√≥n al problema que queremos resolver, generando as√≠ un programa (√≥ software).

Los primeros lenguajes de programaci√≥n se escrib√≠an en instrucciones que pod√≠an interpretar las computadores muy facilmente, pero que resultaban menos amigables a las personas, tales como el lenguaje ensamblador (o Assembler) o Fortran, desarrollado en 1955. Con el tiempo, esto fue cambiando, se fueron desarrolando lenguajes de programaci√≥n de m√°s alto nivel y con diferentes aplicaciones, que por lo general eran comerciales o cient√≠ficas, pero tambien con fines educativos, es decir, lenguajes desarrollados para aprender a programar, y consecuentemente, tambi√©n sea m√°s sencillo. 

√âste √∫ltimo, es el caso de **Python**, que nace a finales de la d√©cada del 80 y fue pensado para principiantes por su facilidad de aprendizaje y uso. Su c√≥digo era compacto pero legible. Con el correr de los a√±os fue incluyendo mejoras hasta llegar tambien a ser de licencia libre. Hoy por hoy, es usado desde en simples "scripts", hasta grandes servidores web que proveen servicio ininterrumpido las 24hs. Es utilizado para la programaci√≥n de interfaces gr√°ficas y bases de datos. Adem√°s tiene una amplia aceptaci√≥n por cient√≠ficos que hacen aplicaciones para las supercomputadores m√°s r√°pidas del mundo y por los ni√±os que reci√©n est√°n comenzando a programar.
La generalizaci√≥n del Big Data en los √∫ltimos a√±os, seguida de la explosi√≥n de la Inteligencia Artificial, Machine Learning y el surgimiento de la Ciencia de Datos como un nuevo √°rea de trabajo con especialistas propios, ha revolucionado el panorama ya que muchas de las nuevas herramientas que han surgido han sido desarrolladas en Python o nos ofrecen Python como la forma predilecta de interactuar con ellas.
Podemos hablar de tecnolog√≠a para Big Data como PySpark, de herramientas para Data Science como Pandas, NumPy, Matplotlib o Jupyter. De herramientas del procesamiento del lenguaje natural como NLTK, y por √∫ltimo el √°rea de Deep Learning como Tensorflow, MXNet o Scikit-Learn.

## Sintaxis de un lenguaje de programaci√≥n

Para el ejemplo se uso un lenguaje con el que era posible determinar los pasos a seguir por el robot abeja hasta llegar a la flor, y nos fue suficiente para poder entender como resolver√≠amos el problema. El hecho es que, los lenguajes de programaci√≥n que utilizamos, deben ser m√°s espec√≠ficos todav√≠a, necesitamos tener un nivel de detalle mayor en nuestras instrucciones, por ejemplo, en lugar de la instruccion "Arriba", podr√≠a ser, especificar la cantidad de celdas que hay que moverse, e incluso qu√© implica "moverse", que seguramente ser√° cambiar el estado de la propia abeja. 
Por otro lado tambien habr√° un marco de referencia, es decir, el tablero donde se mueve la abeja y est√° la flor, en s√≠ mismo, es algo que debemos conocer, saber donde hay ubicado un arbusto y donde no, saber cuales son los l√≠mites, y que pasa si con las instrucciones que le damos a la abeja, hacemos que rebase esos l√≠mites.
Para solventar esa complejidad, necesitamos un **set de instrucciones** un poco m√°s complejo para poder interactuar con el computador y una forma de representar los datos de la realidad, es decir, dimensiones del tablero donde se mueve la abeja, posici√≥n de la abeja, posici√≥n de la flor, ubicaciones de los arbustos. Esto se hace mediante lo que se conoce como **estructuras** de datos, las cuales permiten representar la realidad. De hecho, todos **los datos son una representaci√≥n de la realidad**.
La sintaxis de un programa, consiste en un conjunto de palabras reservadas a instrucciones, con una estructura espec√≠fica, tal y como funciona un lenguaje como el que usamos los humanos para comunicarnos, como el espa√±ol o el ingl√©s. Los lenguajes de programaci√≥n tambien tienen su sintaxis, que esta compuesta por diferentes elementos, como ser variables para representar el dato de la realidad, sentencias para representar las instrucciones √≥ estructuras de control que conforman el cuerpo del programa.

### El Zen de Python 

Es una colecci√≥n de los 19 principios que influyen en el dise√±o del lenguaje Ptyhon. De alguna manera, muestran la filosof√≠a del mismo:

1) Bello es mejor que feo.
2) Expl√≠cito es mejor que impl√≠cito.
3) Simple es mejor que complejo.
4) Complejo es mejor que complicado.
5) Plano es mejor que anidado.
6) Espaciado es mejor que denso.
7) La legibilidad es importante.
8) Los casos especiales no son lo suficientemente especiales como para romper las reglas.
9) Sin embargo la practicidad gana a la pureza.
10) Los errores nunca deben pasar silenciosamente.
11) A menos que se silencien expl√≠citamente.
12) Frente a la ambig√ºedad, evitar la tentaci√≥n de adivinar.
13) Deber√≠a haber una, y preferiblemente solo una, manera obvia de hacerlo.
14) A pesar de que esa manera no sea obvia a menos que seas Holand√©s (el creador lo era)
15) Ahora es mejor que nunca.
16) A pesar de que nunca es muchas veces mejor que ahora mismo.
17) Si la implementaci√≥n es dif√≠cil de explicar, es una mala idea.
18) Si la implementaci√≥n es f√°cil de explicar, puede que sea una buena idea.
19) Los namespaces son una gran idea, ¬°tengamos m√°s de esos!

## Variables

Una variable es un espacio de memoria donde guardamos un dato, ese espacio de memoria a la vez recibe un nombre:

![unaImagenConBoxShadow](../_src/assets/02_imagen01.jpg)

Y esto conforma la estructura de datos m√°s simple que podemos encontrar.

Por otro lado existen ciertas normas a la hora de nombrar variables:

* El nombre no puede empezar con un n√∫mero
* No se permite el uso de guiones del medio -
* No se permite el uso de espacios.
* No usar nombres reservados para Python. Las palabras reservadas son utilizadas por Python internamente, por lo que no podemos usarlas para nuestras variables o funciones.

## Constantes

Sin embargo, cuando ese dato no lo alojamos en una variable y lo utilizamos directamente, recibe el nombre de constante.

## Tipos de Datos

Es importante notar, que podemos encontrarnos con datos de tipos distintos, es decir num√©ricos, alfanum√©ricos o booleanos.

En Python tenemos los siguientes:
 * Enteros: El conjunto de n√∫meros naturales
 * Floats: El conjunto de n√∫meros reales o de punto flotante
 * Cadenas o Strings: Es texto, caracteres alfanum√©ricos que se introducen entre comillas dobles o simples
 * Booleanos: Representan Verdadero √≥ Falso
 * Complejos: El conjunto de n√∫meros complejos

Todo valor que pueda ser asignado a una variable tiene asociado un tipo de dato y esto establece qu√© operaciones se pueden realizar sobre la misma.

## Operaciones entre Variables

Con diferentes tipos de datos podemos hacer diferentes tipos de operaciones. Y hay operaciones no permitidas entre variables de diferentes tipos de datos.

Tipos de datos num√©ricos:

| Operacion | Operador | Ejemplo |
| :---      |  :----:  |    ---: |
| Suma      | + | 3 + 5.5 = 8.5 |
| Resta   | -  | 4 - 1 = 3  |
| Multiplicaci√≥n | *  | 4 * 2 = 8  |
| Potenciaci√≥n | 4<sup>2</sup>  | 4**2 = 16  |
| Divisi√≥n (Cociente) | /  | 4 / 2 = 2  |
| Divisi√≥n (parte entera) | //  | 14 // 3 = 4  |
| Divisi√≥n (resto) | %  | 14 % 3 =  2 |

Operadores relacionales

| Operacion | Operador | Ejemplo |
| :---      |  :----:  |    ---: |
| == | Igual | 10 == 3 = False |
| != | Distinto | 10 != 3 = True |
| >	| Mayor	| 10 > 3 = True |
| < | Menor	| 10 < 3 = False |
| >= | Mayor o igual | 10 >= 3 = True |
| <= | Menor o igual | 10 <= 3 = False |

Operaciones de asignaci√≥n:

| Operacion | Operador | Ejemplo |
| :---      |  :----:  |    ---: |
| =   | x=7  | x=7  |
| +=  | x+=2  | x=x+2 = 9  |
| -=  | x-=2  | x=x-2 = 5  |
| *=  | x*=2  | x=x*2 = 14  |
| /=  | x/=2  | x=x/2 = 3.5  |
| %=  | x%=2  | x=x%2 = 1  |
| //=  | x//=2  | x=x//2 = 3  |
| **=  | x**=2  | x=x**2 = 49  |
| &=  | x&=2  | x=x&2 = 2  |
| |=  | x|=2  | x=x|2 = 7  |
| ^=  | x^=2  | x=x^2 = 5  |
| >>=  | x>>=2  | x=x>>2 = 1  |
| <<= | x<<=2 | x=x<<=2 = 28  |

Cuando tratamos con texto, podemos hacer otras operaciones:

| Operacion | Operador | Ejemplo |
| :---      |  :----:  |    ---: |
| Concatenar | + | 'hola ' + 'mundo !' = 'hola mundo!' |
| Multiplicar | * | 'ja ' + 3 = 'ja ja ja' |

Algunos ejemplos en Python:

```python
>>> a = 'Hola '
>>> b = 'Mundo !'
>>> print(a + b)
Hola Mundo !

>>> x = 3
>>> y = 12
>>> print(x + y)
15

>>> print(a + x)
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
~\AppData\Local\Temp/ipykernel_18232/136165486.py in <module>
----> 1 print(a + x)

TypeError: can only concatenate str (not "int") to str
```

Notar que en la operaciones que no est√°n permitidas arroja un error, que es muy descriptivo. En este caso no es posible sumar un valor entero con un valor alfanum√©rico.

```python
>>> # Dividir "y" entre "x"
>>> y = 9
>>> x = 3
>>> print(y/x)
3.0

>>> # Potencia de "y" elevado a la "x"
>>> y = 2
>>> x = 4
>>> print(y**x)
16

>>> # Devolver el resto de la divisi√≥n
>>> y = 13
>>> x = 3
>>> print(y%x)
1
```

Notar que anteponiendo el caracter numeral (#) es posible agregar comentarios en el c√≥digo.

Operaciones L√≥gicas

Son operaciones en las que entran en uso el tipo de datos booleano, es decir, que nos permiten representar valores verdadero √≥ falso. Para verlo mejor, es necesario recurrir a lo que llamamos tablas de verdad.
Veremos muy comunmente representar verdadero con un "1" y falso con un "0".

Tabla del operador l√≥gico "and", se verifican que A y B sean verdaderas.  
| A | B | A and B |
| :- | :--: | -: |
| 1 | 0 | 0 |
| 0 | 0 | 0 |
| 0 | 1 | 0 |
| 1 | 1 | 1 |

Tabla del operador l√≥gico "or", se verifican que A √≥ B sean verdaderas. 
| A | B | A or B |
| :- | :--: | -: |
| 1 | 0 | 1 |
| 0 | 0 | 0 |
| 0 | 1 | 1 |
| 1 | 1 | 1 |

Tambien es posible representar la negaci√≥n, con el operador not()

Tabla del operador l√≥gico "Or Exclusiva", se verifica ((A and not(B)) or (not(A) and B))
| A | B | A "or exclusiva" B |
| :- | :--: | -: |
| 1 | 0 | 1 |
| 0 | 0 | 0 |
| 0 | 1 | 1 |
| 1 | 1 | 0 |

## Flujos de Control

### Condicionales

Los condicionales son bloques de c√≥digo que se ejecutan √∫nicamente si se cumple una condici√≥n. 
El resultado de esta condici√≥n debe ser booleano (True o False).
Esto se logra mediante la sentencia **if**.
Con la sentencia **elif** se puede agregar un n√∫mero arbitrario de condiciones. 
Por otra parte, se puede ejecutar c√≥digo si la/s condici√≥n/es no se cumple/n con la sentencia **else**.


```python
>>> valor = 0
>>> if (valor < 0):
>>>     print('El n√∫mero es negativo')
>>> elif (valor > 0):
>>>     print('El n√∫mero es positivo')
>>> else:
>>>     print('El n√∫mero es igual a cero')
El n√∫mero es igual a cero
```

### Ciclos Iterativos o Loops

Son bloques de c√≥digo que se repiten una cierta cantidad de veces en funci√≥n de ciertas condiciones.

Un ciclo **for** repite un bloque de c√≥digo tantas veces como elementos haya dentro del rango entre 1 y 10:

```python
>>> for n in range(1,10):
>>>     print(n)
1
2
3
4
5
6
7
8
9
```

Un ciclo **while** repite un bloque de c√≥digo mientras que cierta condici√≥n se cumpla:

```python
>>> n = 1
>>> while (n < 10):
>>>     print(n)
>>>     n = n + 1
1
2
3
4
5
6
7
8
9
```

### Consideraciones

Hemos llegado hasta este punto y se repasaron algunos de los conceptos m√°s fundamentales de la programaci√≥n y tambi√©n de Python, pero es necesario detenerse en algunos detalles, que tienen que ver precisamente con el lenguaje que estamos utilizando:

* En Python es importante la indentaci√≥n, notar que el codigo que se ejecuta dentro de una sentencia if, for o while est√° indentado.
* Tambien es importante notar los ":"
* En Python hay algunas funcionalidades ya presentes por defecto, como por ejemplo la funcion print() que permite mostrar una salida por pantalla y la funci√≥n range() que devuelve un rango num√©rico seg√∫n los par√°metros que recibe y con la funci√≥n type() es posible ver el tipo de dato de una variable
* En Python, cada vez que hagamos referencia a un rango, por ejemplo "1,10" el primer numero se incluye y el √∫ltimo no.

### Sentencia Break

La sentencia break permite alterar el comportamiento de los bucles while y for. Concretamente, permite terminar con la ejecuci√≥n del bucle. Esto significa que una vez se encuentra la palabra break, el bucle se habr√° terminado.
Veamos como podemos usar el break con bucles for. El range(5) generar√≠a 5 iteraciones, donde la i valdr√≠a de 0 a 4. Sin embargo, en la primera iteraci√≥n, terminamos el bucle prematuramente.
El break hace que nada m√°s empezar el bucle, se rompa y se salga sin haber hecho nada.

```python
>>> for i in range(5):
>>>   print(i)
>>>   break
0
```

Un ejemplo un poco m√°s √∫til, ser√≠a el de buscar una letra en una palabra. Se itera toda la palabra y en el momento en el que se encuentra la letra que busc√°bamos, se rompe el bucle y se sale. Esto es algo muy √∫til porque si ya encontramos lo que est√°bamos buscando, no tendr√≠a mucho sentido seguir iterando la lista, ya que desperdiciar√≠amos recursos.

```python
>>> cadena = 'Python'
>>> for letra in cadena:
>>>     if letra == 'h':
>>>         print("Se encontr√≥ la h")
>>>         break
>>>     print(letra)
P
y
t
Se encontr√≥ la h
```

El break tambi√©n nos permite alterar el comportamiento del while. En el ejemplo, la condici√≥n while True har√≠a que la secci√≥n de c√≥digo se ejecutara indefinidamente, pero al hacer uso del break, el bucle se romper√° cuando x valga cero.

```python
>>> x = 5
>>> while True:
>>>     x -= 1
>>>     print(x)
>>>     if x == 0:
>>>         break
>>>     print("Fin del bucle")
4
3
2
1
0
Fin del bucle
```

Por norma general, y salvo casos muy concretos, si ves un while True, es probable que haya un break dentro del bucle.

### Sentencia Continue

El uso de continue al igual que el ya visto break, permite modificar el comportamiento de de los bucles while y for.
Concretamente, continue se salta todo el c√≥digo restante en la iteraci√≥n actual y vuelve al principio en el caso de que a√∫n queden iteraciones por completar.
La diferencia entre el break y continue es que el continue no rompe el bucle, si no que pasa a la siguiente iteraci√≥n saltando el c√≥digo pendiente.
En el siguiente ejemplo vemos como al encontrar la letra P se llama al continue, lo que hace que se salte el print(). Es por ello por lo que no vemos la letra P impresa en pantalla.

```python
>>> cadena = 'Python'
>>> for letra in cadena:
>>>     if letra == 'P':
>>>         continue
>>>     print(letra)
y
t
h
o
n
```

## Estructuras de datos

Anteriormente se menciono que un dato representa la realidad, y se presento el concepto de variable, que es un elemento que nos permite guardar un dato dentro de nuestro programa. Sin embargo, r√°pidamente vamos a llegar a la conclusi√≥n de que una variable puede llegar a quedar insuficiente para ciertas representaciones. Ante esta situaci√≥n, en los lenguajes de programaci√≥n tenemos estructuras de datos m√°s complejas, en el caso de Python contamos con listas, tuplas y diccionarios.

### Lista

Una estructura de dato muy importante en Python es la lista, que consiste en una serie de elementos ordenados.
Esos elementos pueden ser de distinto tipo, e incluso pueden ser de tipo lista tambi√©n.<br>

Operaciones con listas:
* Creacion 
```python
mi_lista = ['Rojo','Azul','Amarillo','Naranja','Violeta','Verde']
```
* Imprimir
```python
print(mi_lista)
```
* Ver el tipo de dato 
```python
type(mi_lista)
```

Las listas, as√≠ como otras estructuras de datos que se ver√°n en adelante, tienen varios elementos, motivo por el cual cuando se quiere acceder en espec√≠fico se requiere de un **√≠ndice** que va a hacer referencia al elemento dentro de la lista:

* Imprimir el tercer elemento de la lista (el √≠ndice comienza en cero)
```python
print(mi_lista[2])
```
* Acceder a un rango dentro de la lista (el limite inferior se incluye y el superior se excluye)
```python
print(mi_lista[0:2])
```
* Al no poner primer valor, Python asume que es un 0
```python
>>> print(mi_lista[:2])
['Rojo', 'Azul']
```
* Al no poner segundo valor, Python asume que se trata de todos los elementos a partir del primero 
```python
 >>> print(mi_lista[0:])
 ['Rojo', 'Azul', 'Amarillo', 'Naranja', 'Violeta', 'Verde']
 ```
* Agregar un elemento al final de la lista (Si el elemento ya existe va a quedar duplicado)
```python
mi_lista.append('Blanco') 
```
* Agregar un elemento especificando el indice 
```python
 >>> mi_lista.insert(3,'Negro')
 >>> print(mi_lista[:])
['Rojo', 'Azul', 'Amarillo', 'Negro', 'Naranja', 'Violeta', 'Verde']
```
* Concatenar una nueva lista a la lista previamente creada 
```python
mi_lista.extend(['Marr√≥n','Gris'])
```
* Encontrar el √≠ndice de un valor espec√≠fico 
```python
>>> print(mi_lista.index('Azul'))
1
```
* Eliminar un elemento de la lista (Si el elemento no existe va a arrojar un error)
```python 
>>> mi_lista.remove('Blanco') 
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
~\AppData\Local\Temp/ipykernel_10044/308548076.py in <module>
----> 1 mi_lista.remove('Blanco')

ValueError: list.remove(x): x not in list
>>> mi_lista.remove('Negro') 
```
* Extraer y recuperar el √∫ltimo elemento de la lista 
```python 
>>> ultimo = mi_lista.pop()
>>> print(ultimo)
Gris
```
* Multiplicar la lista 3 veces 
```python 
>>> print(['a','b','c'] * 3)
['a', 'b', 'c', 'a', 'b', 'c', 'a', 'b', 'c']
```

### Tupla

La diferencia con la lista es que no se pueden modificar una vez creadas, es decir que son **inmutables**:

* Convertir una lista a tupla 
```python 
mi_tupla=tuple(mi_lista)
```
* Imprimir el √≠ndice 1 de la tupla 
```python 
>>> print(mi_tupla[1])
Azul
```
* Evaluar si un elemento est√° contenido en la tupla (Devuelve un valor booleano)
```python
>>> 'Rojo' in mi_tupla
True
```
* Evaluar las veces que est√° un elemento espec√≠fico 
```python
>>> mi_tupla.count('Rojo')
1
```
* Tupla con un solo elemento 
```python
mi_tupla_unitaria = ('Blanco',)
```
* Empaquetado de tupla, tupla sin par√©ntesis 
```python
mi_tupla='Gaspar', 5, 8, 1999
```
* Desempaquetado de tupla, se guardan los valores en orden de las variables 
```python
>>> nombre, dia, mes, a√±o = mi_tupla
>>> print("Nombre: ", nombre, " - Dia:", dia, " - Mes: ", mes, " - A√±o: ", a√±o)
Nombre:  Gaspar  - Dia: 5  - Mes:  8  - A√±o:  1999
```
* Convertir una tupla en una lista 
```python
mi_lista=list(mi_tupla)
```

### Diccionario

Un diccionario tiene una organizaci√≥n de 'clave' y 'valor':

* Crear un diccionario 
```python
mi_diccionario = {  'Colores Primarios': ['Rojo','Azul','Amarillo'], 
                    'Colores secundarios': ['Naranja','Violeta','Verde'], 
                    'Clave3': 10,
                    'Clave4': False}
```
* Imprimir un valor a trav√©s de su clave 
```python
>>> print(mi_diccionario['Colores secundarios'])
['Naranja', 'Violeta', 'Verde']
```
* Agregar un valor 
```python
mi_diccionario['Clave5']='Otro ejemplo'
```
* Cambiar un valor 
```python
mi_diccionario['Clave3']=2
```
* Eliminar un elemento de un diccionario a trav√©s de su clave 
```python
del mi_diccionario['Clave4']
```
* Utilizar una tupla como clave de un diccionario 
```python
mi_tupla=("Argentina", "Italia", "Inglaterra")
mi_diccionario={mi_tupla[0]:"Buenos Aires", 
                mi_tupla[1]:"Roma", 
                mi_tupla[2]:"Londres"}
```
* Colocar una tupla dentro de un diccionario 
```python
mi_diccionario={'Clave1':'Valor1', 'Clave2':(1,2,3,4,5)}
```
* Colocar una lista dentro de un diccionario (Notar que la diferencia est√° en el par√©ntesis '()' y el corchete '[]')
```python
 mi_diccionario={'Clave1':'Valor1', 'Clave2':[1,2,3,4,5]} 
 ```
* Colocar un diccionario dentro de un diccionario 
```python
mi_diccionario={'Clave1':'Valor1', 'Clave2':{'numeros':[1,2,3,4,5]}}
```
* Imprimir las claves del diccionario 
```python
 >>> print(mi_diccionario.keys())
 dict_keys(['Clave1', 'Clave2'])
 ```
* Imprimir los valores del diccionario 
```python
 >>> print(mi_diccionario.values())
 dict_values(['Valor1', {'numeros': [1, 2, 3, 4, 5]}])
 ```
* Imprimir la longitud del diccionario 
```python
 >>> len(mi_diccionario)
 2
 ```

#### Consideraciones

* La funcionalidad **del** permite eliminar cualquier estructura de datos
* La funcionalidad **len** permite obtener el tama√±o de la estructura de datos

## Iteradores e iterables

Permiten iterar colecciones de datos que sean iterables. Si tenemos una determinada colecci√≥n de datos, en este caso una lista con varios valores, y queremos mostrar sus valores uno a uno por pantalla podr√≠a resolverse de la siguiente manera con un while.

```python
>>> lista = [5, 4, 9, 2]
>>> i = 0
>>> while i < len(lista):
>>>     elemento = lista[i]
>>>     print(elemento)
>>>     i += 1
5
4
9
2
```

Aunque es una forma v√°lida, en Python existe una forma mucho m√°s f√°cil de iterar una lista. Dicha forma es la siguiente.

```python
>>> lista = [5, 4, 9, 2]
>>> for elemento in lista:
>>>     print(elemento)
5
4
9
2
```

### Iterables

Una clase iterable es una clase que puede ser iterada. Dentro de Python hay gran cantidad de clases iterables como las listas, strings, diccionarios o archivos. Si tenemos una clase iterable, podemos usarla a la derecha del for de la siguiente manera.

```python
for elemento in [clase_iterable]:
```

En el ciclo for, como se puede ver, la variable elemento ir√° tomando los valores de cada elemento presente en la clase iterable. De esta manera, ya no tenemos que ir accediendo manualmente con [] a cada elemento.
Anteriormente hemos visto un ejemplo iterando una lista, pero tambi√©n podemos iterar una cadena, ya que es una clase iterable. Al iterar una cadena se nos devuelve cada letra presente en la misma. La sintaxis se asemeja bastante al lenguaje natural, ser√≠a algo as√≠ como decir ‚Äúponer en c cada elemento presente en la cadena‚Äù.

```python
>>> cadena = "Hola"
>>> for c in cadena:
>>>     print(c)
H
o
l
a
```

Para saber si una clase es iterable o no hay dos opciones. La primera ser√≠a consultar la documentaci√≥n oficial de Python. La segunda es ver si la clase u objeto en cuesti√≥n hereda de Iterable. Con isinstance() podemos comprobar si una clase hereda de otra.

```python
>>> from collections import Iterable
>>> cadena = "Hola"
>>> numero = 3
>>> print("cadena", isinstance(cadena, Iterable))
>>> print("numero", isinstance(numero, Iterable))
cadena True
numero False
```

Python nos ofrece tambi√©n diferentes m√©todos que pueden ser usados sobre clases iterables como los que se muestran a continuaci√≥n:

* list() convierte a lista una clase iterable
* sum() para sumar
* join() permite unir cada elemento de una clase iterable con el primer argumento usado.

```python
>>> print(list("Hola"))
['H', 'o', 'l', 'a']

>>> print(sum([1, 2, 3]))
6

>>> print("-".join("Hola"))
H-o-l-a
```

De la misma forma que iteramos una cadena o una lista, tambi√©n podemos iterar un diccionario. El iterador del diccionario devuelve las claves o keys del mismo.

```python
>>> mi_dict = {'a':1, 'b':2, 'c':3}
>>> for i in mi_dict:
>>>     print(i)
a
b
c
```

### Iteradores

Se podr√≠a explicar la diferencia entre iteradores e iterables usando un libro como analog√≠a. El libro ser√≠a nuestra clase iterable, ya que tiene diferentes p√°ginas a las que podemos acceder. El libro podr√≠a ser una lista, y cada p√°gina un elemento de la lista. Por otro lado, el iterador ser√≠a un marcap√°ginas, es decir, una referencia que nos indica en qu√© posici√≥n estamos del libro, y que puede ser usado para ‚Äúnavegar‚Äù por √©l.
Es posible obtener un iterador a partir de una clase iterable con la funci√≥n iter(). En el siguiente ejemplo podemos ver como obtenemos el iterador del libro.

```python
>>> libro = ['p√°gina1', 'p√°gina2', 'p√°gina3', 'p√°gina4']
>>> marcapaginas = iter(libro)
```

Llegados a este punto, nuestro marcapaginas almacena un iterador. Se trata de un objeto que podemos usar para navegar a trav√©s del libro. Usando la funci√≥n next() sobre el iterador, podemos ir accediendo secuencialmente a cada elemento de nuestra lista (las p√°ginas de libro).

```python
>>> print(next(marcapaginas))
>>> print(next(marcapaginas))
>>> print(next(marcapaginas))
>>> print(next(marcapaginas))
p√°gina1
p√°gina2
p√°gina3
p√°gina4
```

Algo parecido a esto es lo que sucede por debajo cuando usamos el for sobre una clase iterable. Se va accediendo secuencialmente a los elementos hasta que la excepci√≥n StopIteration es lanzada. Dicha excepci√≥n se lanza cuando hemos llegado al final, y no existen m√°s elementos que iterar.

```python
>>> print(next(marcapaginas))
---------------------------------------------------------------------------
StopIteration                             Traceback (most recent call last)
~\AppData\Local\Temp/ipykernel_10044/1391636315.py in <module>
----> 1 print(next(marcapaginas))
```

Una nota muy importante es que cuando el iterador es obtenido con iter() como hemos visto, apunta por defecto fuera de la lista. Es decir, si queremos acceder al primer elemento de la lista, deberemos llamar una vez a next().
Por otro lado, a diferencia de un marcap√°ginas de un libro, el iterador s√≥lo puede ir hacia delante. No es posible retroceder.


### Sentencia zip

Si pasamos dos listas a zip como entrada, el resultado ser√° una tupla donde cada elemento tendr√° todos y cada uno de los elementos i-√©simos de las listas pasadas como entrada.

```python
>>> a = [1, 2]
>>> b = ["Uno", "Dos"]
>>> c = zip(a, b)
>>> type(c)
zip
>>> list(c)
[(1, 'Uno'), (2, 'Dos')]
```

### A√±adiendo condicionales

Hemos visto como modificar todos los elementos de un iterable (como una lista) de diferentes maneras, pero ¬øy si quisi√©ramos realizar la operaci√≥n sobre el elemento s√≥lo si una determinada condici√≥n se cumple? Debemos a√±adir un condicional if. 
La expresi√≥n gen√©rica ser√≠a la siguiente.

lista = [expresi√≥n for elemento in iterable if condici√≥n]

Por lo tanto la expresi√≥n s√≥lo se aplicar√° al elemento si se cumple la condici√≥n. Veamos un ejemplo con una frase, de la que queremos saber el n√∫mero de erres que tiene.

```python
>>> frase = "El perro de san roque no tiene rabo"
>>> erres = [i for i in frase if i == 'r']
>>> print(errores)
['r', 'r', 'r', 'r']
>>> print(len(erres))
4
```

Lo que hace el c√≥digo anterior es iterar cada letra de la frase, y si es una r, se a√±ade a la lista. De esta manera el resultado es una lista con tantas letras r como la frase original tiene, y podemos calcular las veces que se repite con len().

## Funciones

Las funciones son una secuencia de comandos que ejecutan una secci√≥n de c√≥digo. En Python las funciones se definen usando la palabra reservada **def** y luego el nombre de la funci√≥n con par√©ntesis y dos puntos que indican que lo que sigue son las sentencias, eventualmente una funci√≥n debe retornar un valor, para esto se usa la palabra reservada **return**.

### Limites al declarar funciones

* Los nombres no pueden comenzar con digitos
* No pueden utilizar una palabra reservada
* Las variables deben tener diferentes nombres
* Los nombres de las funciones deben ser descriptivas de lo que hacen las funciones "Imprimir_valor_variable"
* Los par√°metros pueden tener valores por defecto.
* Se puede devolver ningun, uno o m√°s de un valor, y de diferentes tipos de datos.
* Se puede asignar a variables, el resultado de retorno de una funci√≥n.

Para poder imprimir el valor de una variable dentro de un string podemos hacerlo as√≠:

```python  
>>> def imprimir_valor_variable(var):
>>>     print('El valor de la variable es' + str(var))
```

Para devolver dos n√∫meros ordenados de menor a mayor podemos hacerlo as√≠:

```python
>>> def ordenar_dos_numeros(num1=0, num2=0):
>>>     if (num1 > num2):
>>>         return num2, num1
>>>     else:
>>>         return num1, num2
```

### Declarar y Ejecutar

Declarar una funci√≥n es escribir su estructura y ejecutar una funci√≥n es llamar la funci√≥n y ejecutar su c√≥digo, estas dos cosas ocurren en sentencias diferentes.

### Donde se puede acceder a las variables

Cada vez que una funci√≥n se ejecuta se genera un contenedor donde las variables de la funci√≥n van a vivir, una vez se sale de la funci√≥n estas variables dejan de existir, esto se denomina espacio de nombres, alcance o scope de la funci√≥n.
Dentro de una funci√≥n puede haber una variable que solo se pueda utilizar dentro del cuerpo de la funci√≥n, son **variables locales**. Mientras que las variables en el c√≥digo desde el cual se llama a la funci√≥n, son **variables globales**.

![unaImagenConBoxShadow](../_src/assets/02_imagen07.jpg)

``` python
>>> def dividir(dividendo, divisor = 1):
>>>     if (divisor == 0):
>>>         return 'No se puede dividir por cero'
>>>     else:
>>>         return dividendo / divisor
>>> print(dividir(10))
10.0
>>> print(divisor)
---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
~\AppData\Local\Temp/ipykernel_10044/1862935505.py in <module>
----> 1 print(divisor)

NameError: name 'divisor' is not defined
``` 

En este caso, 'divisor' es una variable local dentro de la funci√≥n. Deja de existir cuando termina el llamado a la funci√≥n, lo que denota el mensaje de error es que no encuentra esa variable para imprimir, porque de hecho, solo existi√≥ dentro del espacio de nombres de la funci√≥n.

``` python
>>> divisor = 5
>>> def dividir(dividendo):
>>>     if (divisor == 0):
>>>         return 'No se puede dividir por cero'
>>>     else:
>>>         return dividendo / divisor
>>> print(dividir(10))
2.0
>>> print(divisor)
5
``` 

En este caso 'divisor' es una variable global. En el llamado de la funci√≥n, como no encuentra una variable local llamada 'divisor', busca una variable global llamada 'divisor'. Desde dentro de la funci√≥n, si se tiene acceso al espacio de nombres que la invoca.

``` python
>>> divisor = 5
>>> def dividir(dividendo, divisor = 1):
>>>     if (divisor == 0):
>>>         return 'No se puede dividir por cero'
>>>     else:
>>>         return dividendo / divisor
>>> print(dividir(10))
10.0
>>> print(divisor)
5
``` 

En este caso existe 'divisor' como variable global y 'divisor' como variable local. El llamado a la funci√≥n usa siempre primero la variable local.

### Recursividad

En ocasiones, seg√∫n la problem√°tica que se quiera resolver, podemos utilizar la recursividad, que consiste en una funci√≥n que hace referencia a s√≠ misma. Python lo permite admitiendo el uso de las **llamadas recursivas**.
Entre las ventajas de usar funciones podemos encontrar que se obtiene c√≥digo reutilizable y m√°s prolijo o legible.
Es importante notar tambi√©n que se puede documentar, mediante la inserci√≥n de comentarios y el uso de la funci√≥n help().

``` python
>>> def factorial(numero):
>>>     '''
>>>     Devuelve el factorial
>>>     '''
>>>     if (numero > 1):
>>>         numero = numero * factorial(numero - 1)
>>>     return numero
>>> factorial(3)
6
>>> help(factorial)
Help on function factorial in module __main__:

factorial(numero)
    Devuelve el factorial
``` 

### Pasaje de par√°metros por valor y referencia

En muchos lenguajes de programaci√≥n existen los conceptos de paso por valor y por referencia que aplican a la hora de como trata una funci√≥n a los par√°metros que se le pasan como entrada. Su comportamiento es el siguiente:

Si usamos un par√°metro pasado por **valor**, se crear√° una copia local de la variable, lo que implica que cualquier modificaci√≥n sobre la misma no tendr√° efecto sobre la original.
Con una variable pasada como **referencia**, se actuar√° directamente sobre la variable pasada, por lo que las modificaciones afectar√°n a la variable original.
En Python las cosas son un poco distintas, y el comportamiento estar√° definido por el tipo de variable con la que estamos tratando. 

Veamos un ejemplo de paso por valor.
``` python
>>> x = 10
>>> def funcion(entrada):
>>>     entrada = 0
>>> funcion(x)
>>> print(x)
10
``` 

Iniciamos la x a 10 y se la pasamos a funcion(). Dentro de la funci√≥n hacemos que la variable valga 0. Dado que Python trata a los int como pasados por valor, dentro de la funci√≥n se crea una copia local de x, por lo que la variable original no es modificada.

No pasa lo mismo si por ejemplo x es una lista como en el siguiente ejemplo. En este caso Python lo trata como si estuviese pasada por referencia, lo que hace que se modifique la variable original. La variable original x ha sido modificada.

``` python
>>> x = [10, 20, 30]
>>> def funcion(entrada):
>>>     entrada.append(40)
>>> 
>>> funcion(x)
>>> print(x)
[10, 20, 30, 40]
```

El ejemplo anterior nos podr√≠a llevar a pensar que si en vez de a√±adir un elemento a x, hacemos x=[], estar√≠amos destruyendo la lista original. Sin embargo esto no es cierto.

``` python
>>> x = [10, 20, 30]
>>> def funcion(entrada):
>>>     entrada = []
>>> funcion(x)
>>> print(x)
[10, 20, 30]
``` 

Una forma muy √∫til de saber lo que pasa por debajo de Python, es haciendo uso de la funci√≥n id(). Esta funci√≥n nos devuelve un identificador √∫nico para cada objeto. Volviendo al primer ejemplo podemos ver como los objetos a los que ‚Äúapuntan‚Äù x y entrada son distintos.

``` python
>>> x = 10
>>> print(id(x))
4349704528
>>> def funcion(entrada):
>>>     entrada = 0
>>>     print(id(entrada))
>>> funcion(x)
4349704208
>>> print(x)
10
``` 

Sin embargo si hacemos lo mismo cuando la variable de entrada es una lista, podemos ver que en este caso el objeto con el que se trabaja dentro de la funci√≥n es el mismo que tenemos fuera.

``` python
>>> x = [10, 20, 30]
>>> print(id(x))
4422423560
>>> def funcion(entrada):
>>>     entrada.append(40)
>>>     print(id(entrada))
>>> funcion(x)
4422423560
>>> print(x)
[10, 20, 30, 40]
```

Entonces, en Python por defecto los valores simples se pasan por valor (int, float, string, bool, complex)

### Consideraciones

Es importante notar que cuando se hacen asignaciones entre variables, si no usamos el m√©todo copy(), lo que vamos a estar haciendo en realidad, es referenciar al mismo valor con dos variables distintas, pero esto ocurre s√≥lo ante tipos de datos complejos. 
Sigamos el ejemplo:


```python
>>> # Se crea la variable x con el valor 1
>>> x = 1
>>> # Se asigna x a la variable y
>>> y = x
>>> # Se modifica la variable y asign√°ndole el valor 2
>>> y = 2
>>> # ¬øQu√© valor ahora tienen ambas?
>>> print(x)
1
>>> print(y)
2
```

Vamos a hacer el mismo proceso, pero asignando una lista:

```python
>>> # Se crea la variable x con la lista [1,2]
>>> x = [1,2]
>>> # Se asigna x a la variable y
>>> y = x
>>> # Se modifica la variable y agregando un elemento
>>> y.append(3)
>>> # ¬øQu√© valores ahora tienen ambas?
>>> print(x)
[1,2,3]
>>> print(y)
[1,2,3]
```

Notar que ahora x e y referencian al mismo espacio de memoria, el cu√°l contiene la lista [1,2,3].<br>
Ahora se utiliza el m√©todo copy():

```python
>>> # Se crea la variable x con la lista [1,2]
>>> x = [1,2]
>>> # Se asigna x a la variable y
>>> y = x.copy()
>>> # Se modifica la variable y agregando un elemento
>>> y.append(3)
>>> # ¬øQu√© valores ahora tienen ambas?
>>> print(x)
[1,2]
>>> print(y)
[1,2,3]
```

Notar que ahora x e y referencian a espacios de memoria distintos.

### Funciones Lambda

La funci√≥n Lambda es una forma conveniente de crear una funci√≥n en una sola l√≠nea. Tambi√©n se las conoce como funciones an√≥nimas, ya que no tienen nombre, sino que se asignan a una variable.

* Pueden tener cualquier cantidad de argumentos, pero solo una expresi√≥n.
* No necesitan un return.
* Muy c√≥modas para crear funciones r√°pido.

``` python
>>> lambda_producto = lambda x, y: x * y
>>> lambda_producto(3, 4)
12
``` 

## Clases y objetos (POO)

El alto grado de planificaci√≥n y previsi√≥n que requiere la programaci√≥n es contrario a la propia realidad. El hombre aprende y crea a trav√©s de la experimentaci√≥n, no de la planeaci√≥n. La Orientaci√≥n a Objetos (POO) brinda estos m√©todos de experimentaci√≥n, y logra que los lenguajes sean de m√°s alto nivel, es decir, m√°s cercanos a como los humanos pensamos el mundo. Es decir, vemos la realidad como objetos que se interrelacionan y realizan acciones, y esto, es lo que se intenta emular en la POO.
Hasta 1966 la programaci√≥n fue exclusivamente lineal, hasta que surgieron lenguajes como Simula, SmallTalk, C++, Ada, Delphi o Java. Hoy el lenguaje m√°s popular es Python y su filosof√≠a hace hincapi√© en la legibilidad de su c√≥digo. 

### Objeto

Una estructura de datos que eventualmente tiene funciones asociadas, que est√°n agrupados por razones de consistencia y comodidad conforman un **objeto**.
En la composici√≥n de un objeto tenemos entonces **propiedades** (datos) y **m√©todos** (funciones asociadas).

### Clase

Hay una diferencia muy importante entre un objeto y una variable, y es que mientras que la variable 'se crea', el objeto 'se instancia', lo que implica, ademas de su creaci√≥n propiamente dicha, que su creaci√≥n se realiza en base a una definici√≥n preliminar, disponibilizando en memoria, no solo la estructura de datos asociada sino sus m√©todos. Por medio de esta mec√°nica, adem√°s, se puede instanciar m√°s de un solo objeto con la misma definicion. Esta definici√≥n, es una generalizaci√≥n del objeto, es decir que especifica que estructura de datos va a tener y qu√© m√©todos asociados. Esto lo que se conoce como **clase**

### Pilares de la Programaci√≥n Orientada a Objetos

* **Abstracci√≥n**: Es cuando separamos los datos de un objeto para luego generar un molde (una clase).
* **Encapsulamiento**: Se utiliza cuando es necesario que ciertos m√©todos o propiedades sean inviolables o inalterables.
Un ejemplo del encapsulamiento podr√≠a ser una cuenta de banco, donde el usuario no puede simplemente aumentar su balance de dinero, si no que debe depender de unos m√©todos previamente validados para aumentar dicho balance (dep√≥sitos, transferencias, etc).
* **Herencia**: Permite crear nuevas clases a partir de otras. Si tuvi√©ramos una clase ‚ÄúAutos‚Äù y quisi√©ramos crear unas clases ‚ÄúAuto deportivo‚Äù o ‚ÄúAuto cl√°sico‚Äù, podr√≠amos tomar varias propiedades y m√©todos de la clase ‚ÄúAutos‚Äù. Esto nos da una jerarqu√≠a de padre e hijo.
* **Polimorfismo**: Proviene de Poli = muchas, morfismo = formas. Se utiliza para crear m√©todos con el mismo nombre pero con diferente comportamiento.

### Ejemplos:

* Clase Animal<br>
&nbsp;&nbsp;- Especie<br>
&nbsp;&nbsp;- Edad<br>
&nbsp;&nbsp;- Color<br>
&nbsp;&nbsp;- Correr()<br>
&nbsp;&nbsp;- Dormir()<br>

Se instancian distintos objetos a partir de una clase:

* Objeto1<br>
&nbsp;&nbsp;- Especie: 'Perro'<br>
&nbsp;&nbsp;- Edad: 3<br>
&nbsp;&nbsp;- Color: 'Blanco'<br>
&nbsp;&nbsp;- Correr()<br>
&nbsp;&nbsp;- Dormir()<br>

* Objeto2
&nbsp;&nbsp;- Especie: 'Caballo'<br>
&nbsp;&nbsp;- Edad: 8<br>
&nbsp;&nbsp;- Color: 'Marr√≥n'<br>
&nbsp;&nbsp;- Correr()<br>
&nbsp;&nbsp;- Dormir()<br>

* A partir de la sentencia **class** y el nombre de creamos la clase.
* La funci√≥n **__init__()** es el **constructor** de la clase, esta funci√≥n se ejecuta cuando se instancia el objeto.
* La clase posee atributos (especie, edad, color) y m√©todos que manipulan esos atributos (mePresento, cumplirA√±os).

``` python
>>> class Animal:
>>> '''
>>> En esta clase se crean los animales
>>> '''
>>> def __init__(self, especie, edad, color):
>>>     self.especie = especie
>>>     self.edad = edad
>>>     self.color = color
>>> def mePresento(self):
>>>     print('Hola, soy ', self.especie, ', de color', self.color, ' y tengo ', self.edad, ' a√±os')
>>> def cumplirA√±os(self):
>>>     self.edad = self.edad + 1
>>> 
>>> a1 = Animal('Rat√≥n', 2, 'Marr√≥n')
>>> print(a1.especie)
Rat√≥n
>>> print(a1.edad)
2
>>> a2 = Animal('Liebre', 3, 'Gris')
>>> print(a2.especie)
Liebre
>>> print(a2.edad)
3
``` 

Creamos los objetos a1 y a2. Al hacerlo se env√≠an los par√°metros de inicializaci√≥n de sus atributos.
Utilizamos sus m√©todos para mostrar los atributos y/o modificarlos.
Este formato de clases, objetos, m√©todos y par√°metros es muy com√∫n en Python y lo utilizamos cada vez que invocamos alguna de sus **librer√≠as**

``` python
>>> a1.mePresento()
Hola, soy  Rat√≥n , de color Marr√≥n  y tengo  2  a√±os
>>> a2.mePresento()
Hola, soy  Liebre , de color Gris  y tengo  3  a√±os
>>> a1.cumplirA√±os()
>>> a1.mePresento()
Hola, soy  Rat√≥n , de color Marr√≥n  y tengo  3  a√±os
```

## Librer√≠as

Las librer√≠as son proyectos con metodos o funciones puntuales, el cual es posible anexar a otros proyectos y complementarlo usando sus metodos especificos para una determinada soluci√≥n. Son trozos de c√≥digo hechos por terceros. Facilita mucho la programaci√≥n y hace que nuestro programa sea m√°s sencillo de hacer y luego de entender. Tambi√©n llamadas 'Frameworks', consiste en archivos de c√≥digo a los que se invoca al proncipio de nuestro propio c√≥digo.

### M√≥dulos

Un m√≥dulo en Python es un archivo con extensi√≥n ".py" que alberga un conjunto de funciones, variables o clases y que puede ser usado por otros m√≥dulos. Nos permiten reutilizar c√≥digo y organizarlo mejor en namespaces. Por ejemplo, podemos definir un m√≥dulo mimodulo.py con dos funciones suma() y resta().


``` python
>>> # mimodulo.py
>>> def suma(a, b):
>>>     return a + b
>>> 
>>> def resta(a, b):
>>>     return a - b
```

Una vez definido, dicho m√≥dulo puede ser usado o importado en otro c√≥digo usando **import**, con lo que se puede acceder a todo el contenido.

``` python
>>> # otromodulo.py
>>> import mimodulo
>>> 
>>> print(mimodulo.suma(4, 3))
7
>>> print(mimodulo.resta(10, 9))
1
``` 

Tambi√©n podemos importar √∫nicamente los componentes que nos interesen como mostramos a continuaci√≥n.

``` python
>>> from mimodulo import suma, resta
>>> 
>>> print(suma(4, 3))   # 7
>>> print(resta(10, 9)) # 1
```

Por √∫ltimo, podemos importar todo el m√≥dulo haciendo uso de *, sin necesidad de usar mimodulo.*.

``` python
>>> from mimodulo import *
>>> 
>>> print(suma(4, 3))
7
>>> print(resta(10, 9))
1
```

### Consideraciones

Los m√≥dulos o librer√≠as, permiten que Python pueda ser utilizado en diferentes entornos:

- **Desarrollo Web**: Existen frameworks como Django, Pyramid, Flask o Bottle que permiten desarrollar p√°ginas web a todos los niveles.
- **Ciencia y Educaci√≥n**: Debido a su sintaxis tan sencilla, es una herramienta perfecta para ense√±ar conceptos de programaci√≥n a todos los niveles. En lo relativo a ciencia y c√°lculo num√©rico, existen gran cantidad de librer√≠as como SciPy o Pandas.
- **Desarrollo de Interfaces Gr√°ficos**: Gran cantidad de los programas que utilizamos tienen un interfaz gr√°fico que facilita su uso. Python tambi√©n puede ser usado para desarrollar GUIs con librer√≠as como Kivy o pyqt.
- **Desarrollo Software**: Tambi√©n es usado como soporte para desarrolladores, como para testing.
- **Machine Learning**: En los √∫ltimo a√±os ha crecido el n√∫mero de implementaciones en Python de librer√≠as de aprendizaje autom√°tico como Keras, TensorFlow, PyTorch o sklearn.
- **Visualizaci√≥n de Datos**: Existen varias librer√≠as muy usadas para mostrar datos en gr√°ficas, como matplotlib, seaborn o plotly.
Finanzas y Trading: Gracias a librer√≠as como QuantLib o qtpylib y a su facilidad de uso, es cada vez m√°s usado en estos sectores.

### Rutas y Uso de sys.path

Normalmente los m√≥dulos que importamos est√°n en la misma carpeta, pero es posible acceder tambi√©n a m√≥dulos ubicados en una subcarpeta. Imaginemos la siguiente estructura:

``` bash
.
‚îú‚îÄ‚îÄ ejemplo.py
‚îú‚îÄ‚îÄ carpeta
‚îÇ   ‚îî‚îÄ‚îÄ modulo.py
```

Donde modulo.py contiene lo siguiente:

``` python
>>> # modulo.py
>>> def hola():
>>> 	print("Hola")
```

Desde nuestro ejemplo.py, podemos importar el m√≥dulo modulo.py de la siguiente manera:

``` python
>>> from carpeta.modulo import *
>>> print(hola())
Hola
```

Es importante notar que Python busca los m√≥dulos en las rutas indicadas por el **sys.path**. Es decir, cuando se importa un m√≥dulo, lo intenta buscar en dichas carpetas. Puedes ver tu sys.path de la siguiente manera:

``` python
>>> import sys
>>> print(sys.path)
```

Como es obvio, ver√°s que la carpeta de tu proyecta est√° incluida, pero ¬øy si queremos importar un m√≥dulo en una ubicaci√≥n distinta? Pues bien, podemos a√±adir al sys.path la ruta en la que queremos que Python busque.

``` python
>>> import sys
>>> sys.path.append(r'/ruta/de/tu/modulo')
``` 

Una vez realizado esto, los m√≥dulos contenidos en dicha carpeta podr√°n ser importados sin problema como hemos visto anteriormente.

Por otro lado, es posible cambiar el nombre del m√≥dulo usando **as**. Imaginemos que tenemos un m√≥dulo moduloconnombrelargo.py.

``` python
>>> # moduloconnombrelargo.py
>>> hola = "hola"
```

En vez de usar el siguiente import, tal vez queramos asignar un nombre m√°s corto al m√≥dulo.

``` python
>>> import moduloconnombrelargo
>>> print(moduloconnombrelargo.hola)
```

Podemos hacerlo de la siguiente manera con as:

``` python
>>> import moduloconnombrelargo as m
>>> print(m.hola)
``` 

La funci√≥n **dir()** nos permite ver los nombres (variables, funciones, clases, etc) existentes en nuestro namespace. Si probamos en un m√≥dulo vac√≠o, podemos ver como tenemos varios nombres rodeados de __. Se trata de nombres que Python crea por debajo.

``` python
>>> print(dir())
['__annotations__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__']
```

Por ejemplo, __file__ es creado autom√°ticamente y alberga el nombre del archivo .py.

``` python
>>> print(__file__)
/tu/ruta/tufichero.py
```

Imaginemos ahora que tenemos alguna variable y funci√≥n definida en nuestro script. Como era de esperar, dir() ahora nos muestra tambi√©n los nuevos nombres que hemos creado, y que por supuesto pueden ser usados.

``` python
>>> mi_variable = "Python"
>>> def mi_funcion():
>>>     pass
>>> print(dir())
['__annotations__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'mi_funcion', 'mi_variable']
``` 

Por √∫ltimo, vamos a importar el contenido de un m√≥dulo externo. Podemos ver que en el namespace tenemos tambi√©n los nombres resta y suma, que han sido tomados de mimodulo.

``` python
>>> from mimodulo import *
>>> print(dir())
['__annotations__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'resta', 'suma']
```

El uso de dir() tambi√©n acepta par√°metros de entrada, por lo que podemos por ejemplo pasar nuestro modulo y nos dar√° m√°s informaci√≥n sobre lo que contiene.

``` python
>>> import mimodulo
>>> print(dir(mimodulo))
['__builtins__', '__cached__', '__doc__', '__file__','__loader__', '__name__', '__package__', '__spec__', 'resta', 'suma']
>>> print(mimodulo.__name__)
mimodulo
>>> print(mimodulo.__file__)
/tu/ruta/mimodulo.py
```

Importar un m√≥dulo puede lanzar la excepci√≥n "ImportError", cuando se intenta importar un m√≥dulo que no ha sido encontrado. Se trata de ModuleNotFoundError.

``` python
>>> import moduloquenoexiste
ModuleNotFoundError: No module named 'moduloquenoexiste'
``` 

Dicha excepci√≥n puede ser capturada para evitar la interrupci√≥n del programa.
Un problema muy recurrente es cuando creamos un m√≥dulo con una funci√≥n como en el siguiente ejemplo, y a√±adimos algunas sentencias a ejecutar.

``` python
>>> # modulo.py
>>> def suma(a, b):
>>>     return a + b
>>> c = suma(1, 2)
>>> print("La suma es:", c)
```

Si en otro m√≥dulo importamos nuestro modulo.py, tal como est√° nuestro c√≥digo el contenido se ejecutar√°, y esto puede no ser lo que queramos.


``` python
>>> # otromodulo.py
>>> import modulo
La suma es: 3
```

Dependiendo de la situaci√≥n, puede ser importante especificar que √∫nicamente queremos que se ejecute el c√≥digo si el m√≥dulo es el __main__. Con la siguiente modificaci√≥n, si hacemos import modulo desde otro m√≥dulo, este fragmento ya no se ejecutar√° al ser el m√≥dulo main otro.

``` python
>>> # modulo.py
>>> def suma(a, b):
>>>     return a + b
>>> if (__name__ == '__main__'):
>>>     c = suma(1, 2)
>>>     print("La suma es:", c)
```

Es importante notar que los m√≥dulos solamente son cargados una vez. Es decir, no importa el n√∫mero de veces que llamemos a import mimodulo, que s√≥lo se importar√° una vez.
Si queremos que el m√≥dulo sea recargado, tenemos que ser expl√≠citos, haciendo uso de reload.

``` python
>>> import mimodulo
>>> import importlib
>>> importlib.reload(mimodulo)
>>> importlib.reload(mimodulo)
``` 

## Manejo de Errores

### Pruebas de caja negra

Las pruebas de caja negra se basan en la especificaci√≥n de la funci√≥n o el programa, aqu√≠ debemos probar sus inputs y validar los outputs. Se llama caja negra por que no necesitamos saber necesariamente los procesos internos del programa, solo contrastar sus resultados.
Hay dos tipos de pruebas muy importantes:
* Pruebas Unitarias: Se realizan pruebas a cada uno de los m√≥dulos para determinar su correcto funcionamiento.
* Pruebas de Integraci√≥n: Se valida quee todos los m√≥dulos funcionan entre s√≠.

Es una buena pr√°ctica realizar las pruebas antes de crear c√≥digo, esto es por que cualquier cambio que se realice a futuro los test estaran incorporados para determinar si los cambios cumplen lo esperado.
En Python existe la posibilidad de realizar estas pruebas gracias a la libreria **unittest**.

```python
>>> import unittest

>>> def suma(num_1, num_2):
>>>     return abs(num_1) + num_2

>>> class CajaNegraTest(unittest.TestCase):
>>> 
>>>     def test_suma_dos_positivos(self):
>>>         num_1 = 10
>>>         num_2 = 5
>>> 
>>>         resultado = suma(num_1, num_2)
>>> 
>>>         self.assertEqual(resultado, 15)
>>> 
>>>     def test_suma_dos_negativos(self):
>>>         num_1 = -10
>>>         num_2 = -7
>>> 
>>>         resultado = suma(num_1, num_2)
>>> 
>>>         self.assertEqual(resultado, -17)

>>> unittest.main(argv=[''], verbosity=2, exit=False)
test_suma_dos_negativos (__main__.CajaNegraTest) ... ok
test_suma_dos_positivos (__main__.CajaNegraTest) ... ok

----------------------------------------------------------------------
Ran 2 tests in 0.004s

OK
<unittest.main.TestProgram at 0x2226bd08400>
``` 

### Pruebas de caja de cristal

Se basan en el flujo del programa, por lo que se asume que conocemos el funcionamiento del programa, por lo que podemos probar todos los caminos posibles de una funci√≥n. Esto significa que vamos a probar las ramificaciones, bucles for y while, recursi√≥nes, etc.
Este tipo de pruebas son muy buenas cuando descubrimos un bug cuando corremos el programa, por lo que vamos a buscar el **bug** √≥ error de c√≥digo gracias a que conocemos su estructura.

```python
>>> import unittest

>>> def es_mayor_de_edad(edad):
>>>     if edad >= 18:
>>>         return True
>>>     else:
>>>         return False

>>> class PruebaDeCristalTest(unittest.TestCase):
>>> 
>>>     def test_es_mayor_de_edad(self):
>>>         edad = 20
>>> 
>>>         resultado = es_mayor_de_edad(edad)
>>> 
>>>         self.assertEqual(resultado, True)
>>> 
>>>     def test_es_menor_de_edad(self):
>>>         edad = 15
>>> 
>>>         resultado = es_mayor_de_edad(edad)
>>> 
>>>         self.assertEqual(resultado, False)

>>> unittest.main(argv=[''], verbosity=2, exit=False)
test_es_mayor_de_edad (__main__.PruebaDeCristalTest) ... ok
test_es_menor_de_edad (__main__.PruebaDeCristalTest) ... ok

----------------------------------------------------------------------
Ran 2 tests in 0.003s

OK
<unittest.main.TestProgram at 0x2226bd153d0>
```

### Seguir el c√≥digo paso a paso √≥ 'Debugging'

Los bugs son un problema que les sucede a todos, sin embargo si realizamos test a nuestro programa probablemente tendremos menos bugs, pero esto no es suficiente.
Existen unas reglas generales que nos ayudaran:
No te molestes con el debugger. Aprende a utilizar el print statement.
* Estudia los datos disponibles.
* Utiliza los datos para crear hip√≥tesis y experimentos. M√©todo cient√≠fico.
* Ten una mente abierta. Si entendieras el programa, probablemente no habr√≠an bugs.
* Lleva un registro de lo que has tratado, preferentemente en la forma de tests.
* Debuguear es un proceso de b√∫squeda de los bugs, por lo que al dise√±ar nuestros experimentos debemos acotar el espacio de b√∫squeda en cada prueba. Una forma √°gil de debugear es utilizando una b√∫squeda binaria con print statements, esto significa que ejecutamos la mitad del c√≥digo, si no falla entonces sabemos que el problema esta en la otra mitad, y en cada √°rea que vamos acortando lo dividimos por mitades, de esta forma hallaremos r√°pidamente nuestro bug.

Existe un listado de errores comunes de los cuales tambi√©n nos podemos apoyar:
* Encuentra a los sospechosos comunes (llamado a una funci√≥n mal escrita, par√°metros en orden incorrecto, etc.)
* En lugar de preguntarte por qu√© un programa no funciona, preg√∫ntate por qu√© est√° funcionando de esta manera.
* Es posible que el bug no se encuentre donde crees que est√°.
* Expl√≠cale el problema a otra persona. De preferencia que no tenga contexto.
* Lleva un registro de lo que has tratado, preferentemente en la forma de tests.

### Manejo de excepciones

Los manejos de excepciones son muy comunes en la programaci√≥n, no tienen nada de excepcional. Las excepciones de Python normalmente se relacionan con errores de sem√°ntica, tambi√©n podemos crear nuestras propias excepciones, pero cuando una excepci√≥n no se maneja (unhandled exception), el programa termina en error.

Las excepciones se manejan con los keywords: **try**, **except**, **finally**. Se pueden utilizar tambi√©n para ramificar programas.
No deben manejarse de manera silenciosa (por ejemplo, con print statements). Para crear tu propia excepci√≥n utiliza el keyword **raise**.

``` python
>>> def divide_elementos_de_lista(lista, divisor):
>>>     '''
>>>     Cada elemento de una lista es dividida por un divisor definido.
>>>     En caso de error de tipo ZeroDivisionError que
>>>     significa error al dividir en cero
>>>     la funci√≥n devuelve la lista inicial
>>>     '''
>>>     try:
>>>         return [i / divisor for i in lista]
>>>     
>>>     except ZeroDivisionError as e:
>>>         print(e)
>>>         return lista
>>> 
>>> lista = list(range(10))
>>> divisor = 0
>>> 
>>> print(divide_elementos_de_lista(lista, divisor))
division by zero
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> divisor = 3
>>> print(divide_elementos_de_lista(lista, divisor))
[0.0, 0.3333333333333, 0.6666666666666, 1.0, 1.3333333333333, 1.6666666666667, 2.0, 2.3333333333335, 2.6666666666665, 3.0]
```

### Excepciones y control de flujo

Hasta ahora hemos visto como las excepciones nos permiten controlar los posibles errores que pueden ocurrir en nuestro c√≥digo. Sin embargo, dentro de la comunidad de Python tienen otro uso: control de flujo.

¬øPor qu√© es necesaria otra modalidad para controlar el flujo? Una raz√≥n muy espec√≠fica: el principio EAFP (easier to ask for forgiveness than permission, es m√°s f√°cil pedir perd√≥n que permiso, por sus siglas en ingl√©s).

El principio EAFP es un estilo de programaci√≥n com√∫n en Python en el cual se asumen llaves, √≠ndices o atributos v√°lidos y se captura la excepci√≥n si la suposici√≥n resulta ser falsa. Es importante resaltar que otros lenguajes de programaci√≥n favorecen el principio LBYL (look before you leap, revisa antes de saltar) en el cual el c√≥digo verifica de manera expl√≠cita las precondiciones antes de realizar llamadas.

``` python
#Python
def busca_pais(paises, pais):
'''
Paises es un diccionario. Pais es la llave.
Codigo con el principio EAFP.
'''

try:
    return paises[pais]
except KeyError:
     return None
```

``` javascript
// Javascript

/**
* Paises es un objeto. Pais es la llave.
* Codigo con el principio LBYL.
*/
function buscaPais(paises, pais) {
  if(!Object.keys(paises).includes(pais)) {
    return null;
  }

  return paises[pais];
}
``` 

Como se puede ver, el c√≥digo de Python accede directamente a la llave y √∫nicamente si dicho acceso falla, entonces se captura la excepci√≥n y se provee el c√≥digo necesario. En el caso de JavaScript, se verifica primero que la llave exista en el objeto y √∫nicamente con posterioridad se accede.

Es importante resaltar que ambos estilos pueden utilizarse en Python, pero el estilo EAFP es mucho m√°s propio de este lenguaje.

``` python
#All possible errors

except TypeError:
    print("is thrown when an operation or function is applied to an object of an inappropriate type.")
except IndexError:
   	print("is thrown when trying to access an item at an invalid index.")
except KeyError:
    print("is thrown when a key is not found.")
except ImportError:
  	print("Raised when the imported module is not found.")
except StopIteration:
  	print("is thrown when the next() function goes beyond the iterator items.")
except ValueError:
  	print("is thrown when a function's argument is of an inappropriate type.")
except NameError:
  	print("is thrown when an object could not be found.")	
except ZeroDivisionError:
  	print("is thrown when the second operator in the division is zero.")
except KeyboardInterrupt:
  	print("is thrown when the user hits the interrupt key (normally Control-C) during the execution of the program.")
except MemoryError:
  	print("Raised when an operation runs out of memory.")
except FloatingPointError:
  	print("Raised when a floating point operation fails.")
except OverflowError:
  	print("Raised when the result of an arithmetic operation is too large to be represented.")
except ReferenceError:
  	print("Raised when a weak reference proxy is used to access a garbage collected referent.")
except TabError:
  	print("Raised when the indentation consists of inconsistent tabs and spaces.")
except SystemError:
  	print("Raised when the interpreter detects internal error.")
except RuntimeError:
  	print("Raised when an error does not fall under any other category.")
except:
 	print("Error detected can't be handled nor clasified.")
```

## Caracter√≠sticas de Python

- Es un lenguaje interpretado, no compilado.
- Usa tipado din√°mico, lo que significa que una variable puede tomar valores de distinto tipo.
- Es fuertemente tipado, lo que significa que el tipo no cambia de manera repentina. Para que se produzca un cambio de tipo tiene que hacer una conversi√≥n expl√≠cita.
- Es multiplataforma, ya que un c√≥digo escrito en macOS funciona en Windows o Linux y vice versa.